#lab2

1. 线性筛素数

    python版本与c++版本差距太巨大了。

    同样的算法逻辑，同样的数范围（100,000）

    | Language | Result | time detail |
    |----------|--------|-------------|
    |C++       |454,396,537 | real    0m0.008s user    0m0.004s sys     0m0.000s |
    |Python    |454,396,537 | real    0m6.981s user    0m6.940s sys     0m0.008s |

    如上，差了约1000倍！当这个数字更大时，C++的时间开销基本保持不变，而Python却大幅度增加。这里说明，很大可能是Python代码写得有些问题！
    
    !!! 实现了一般线性筛素数方法，在Python下一下子速度提高好快！！ 究竟是为何呢？？

    以下是使用该版本，计算2,000,000内素数和的大小。（结果为142,913,828,922 ， 千亿级别，C++使用`unsigned long long`数据类型，使用sizeof结果为8字节，大约能表示`2^{64} ~ 10^{19} `，很了不起的数字！不过使用long就越界了，sizeof看出字节依然为4，说明**long果然与int一个意思**！）

    | Language | Result | time detail |
    |----------|--------|-------------|
    |C++(Normal)       |142,913,828,922| real    0m0.140s user    0m0.128s sys     0m0.008s |
    |C++(Fast)         |142,913,828,922| real    0m0.095s user    0m0.084s sys     0m0.008s |
    |Python(Normal)    |142,913,828,922| real    0m1.366s user    0m1.228s sys     0m0.124s |
    |Python(Fast)      |142,913,828,922| real    48m8.883s user   45m48.964s sys   2m7.296s |

    以上的结果还是说明： Python还是一门靠优化的语言！纯粹的以循环次数作为时间复杂度是非常不靠谱的！ 然而C++作为编译为汇编的语言，却真真实实的收到循环次数的影响。

    如此一来，Python的门槛还是比较高的。想要优化不易啊。

    其实，我仍然不懂，为何Python的Fast实现如此之慢？
    
    **UPDATE -- 知道为何Fast跑这么慢的原因了**

    梓翔帮忙找到了原因：

    在内层循环，筛去相关合数时，我们使用了`for prime_num_idx in range(0,prime_nums_cnt)  ` 这个是在外层每次循环都要执行的语句！在后面素数找得越来越多的情况下，每次的开销变得越来越大！这个range就相当于一个for循环，开辟了一个prime_nums_cnt大小的数组，有了时间、空间的双重开销，而且空间开销也带来时间的开销！我们知道内存的申请与释放都是比较费时的，外层每个循环都要申请大量内存，同时,内层循环其实也真的跑不了几个就会推出。所以频繁申请释放内存，时间开销也很大。

    ！！使用while+变量或者使用xrange，速度一下就快了！
    
    |Language| Result |time detail|
    |Python + Fast + xrange | 142,913,828,922 | real    0m1.728s user    0m1.640s sys     0m0.084s|
    |Python + Fast + while  | 142,913,828,922 | real    0m1.377s user    0m0.916s sys     0m0.456s |

    如上，果然用while是开销更小的！不过总的来说，比起Normal模式，还是梢慢了一点，不过几乎可以认为是一致的（real time）。而且注意到Fast的Sys time开销是远大于Normal的，而且也是大于xrange的，这或许是说while的循环使用了系统调用？ - - ， 真是不明白啊...


2. 怎么计算两个日期间经过的天数

    想到一种比较容易想的方法！

    **先把时间归一到该年的一月一日.**如1993年4月2日，表示为 `1993年一月一日 + 3个整月 + 2天` ，下一个日期同样处理，如1994年1月5日，表示为`1994年1月1日 + 0个整月 + 5天 ` ， 然后计算两个整年的天数，就是1993年的天数，然后减去其实时间的非整年天数，加上到达日期的非整年天数。这样就计算出来了。

    非常的直观！也非常简单。

    
